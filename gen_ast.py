from io import FileIO
from typing import List


def define_ast(output_file: FileIO, base_name: str, types: List[str], extra_imports: List[str] = []):
    # First write some comments.
    output_file.write(
        "# This file was automatically generated by gen_ast.py.\n")
    output_file.write("from tokens import Token\n")
    output_file.write("from typing import List, Any\n")
    for extra_import in extra_imports:
        output_file.write(f"{extra_import}\n")
    output_file.write("\n")
    define_visitor(output_file, base_name, types)

    output_file.write(f"class {base_name}:\n")
    # define accept method for each type.
    output_file.write(
        f"    def accept(self, visitor : {base_name}Visitor):\n")
    for type in types:
        class_name = type.split(":")[0].strip()
        output_file.write(f"        if isinstance(self, {class_name}):\n")
        output_file.write(
            f"            return visitor.visit_{class_name.lower()}_{base_name.lower()}(self)\n")
    # call default visitor method.
    output_file.write(
        f"        return visitor.default_{base_name.lower()}(self)\n")
    output_file.write("\n")

    for type in types:
        class_name = type.split(":")[0].strip()
        fields = type.split(":")[1].strip()
        define_type(output_file, base_name, class_name, fields)
    output_file.write("\n")


def define_visitor(output_file: FileIO, base_name: str, types: List[str]):
    class_names = [type.split(":")[0].strip() for type in types]
    # Generate an abstract visitor class.
    output_file.write(f"class {base_name}Visitor:\n")
    # Generate the visitor methods for each type. Add quotes to the type name as they haven't been parsed yet.
    for class_name in class_names:
        output_file.write(
            f"    def visit_{class_name.lower()}_{base_name.lower()}(self, node : \"{class_name}\"):\n")
        output_file.write(f"        pass\n")
    # Generate a default visitor method.
    output_file.write(f"    def default_{base_name.lower()}(self, node):\n")
    output_file.write(f"        pass\n")
    output_file.write("\n")


def define_type(output_file: FileIO, base_name: str, class_name: str, fields: str):
    # parse the fields.
    parsed_fileds = []
    for field in fields.split(","):
        field = field.strip()
        field_type = field.split(" ")[0]
        field_name = field.split(" ")[-1]
        parsed_fileds.append((field_type, field_name))

    output_file.write(f"class {class_name}({base_name}):\n")

    # Generate a constructor.
    output_file.write(f"    def __init__(self ")
    # Generate the constructor parameters and their types.
    for field_type, field_name in parsed_fileds:
        output_file.write(f", {field_name} : {field_type}")
    output_file.write(f"):\n")
    for field_type, field_name in parsed_fileds:
        output_file.write(
            f"        self.{field_name} : {field_type} = {field_name}\n")
    # Generate a __str__ method.
    output_file.write(f"    def __str__(self):\n")
    output_file.write(f"        r = \"{class_name}(\"\n")
    # print the fields.
    for field_type, field_name in parsed_fileds:
        output_file.write(
            f"        r += f\"{field_name} : {field_type} = \"\n")
        output_file.write(f"        r += str(self.{field_name})\n")
        output_file.write(f"        r += \",\"\n\n")

    output_file.write(f"        r += \")\"\n")
    output_file.write(f"        return r\n")


def main():
    # Generate ast files in a command line argument <output directory>.
    import argparse
    import sys
    import os
    argparser = argparse.ArgumentParser(
        description='Generate ast files in a command line argument <output directory>.')
    # The argument is the path to the file to be generated.
    argparser.add_argument(
        'output_directory', help='The output directory')
    args = argparser.parse_args()
    if not os.path.exists(args.output_directory):
        print('The output directory does not exist.')
        sys.exit(1)
    if not os.path.isdir(args.output_directory):
        print('The output directory is not a directory.')
        sys.exit(1)
    # Generate the expr.py file.
    output_file = open(os.path.join(
        args.output_directory, 'expressions.py'), 'w')
    define_ast(output_file, "Expr", [
        "Assign   : Token name, Expr value",
        "Binary : Expr left, Token operator, Expr right",
        "Grouping : Expr expression",
        "Literal : Any value",
        "Variable : Token name",
        "Unary : Token operator, Expr right",
    ])

    # Generate the statements.py file.
    output_file = open(os.path.join(
        args.output_directory, 'statements.py'), 'w')
    define_ast(output_file, "Stmt", [
        "Expression : Expr expression",
        "Block : List[Stmt] statements",
        "Var: Token name, Expr initializer",
        "Print : Expr expression"
    ], extra_imports=["from expressions import Expr"])


if __name__ == '__main__':
    main()
